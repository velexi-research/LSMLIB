%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% reinitializeLevelSetFunction reinitializes the level set function to be
% a signed distance function.
%
% Usage: phi = reinitializeLevelSetFunction(phi_init, ...
%                                           ghostcell_width, ...
%                                           dX, ...
%                                           max_iterations, ...
%                                           spatial_derivative_order, ...
%                                           tvdrk_order)
%
% Arguments:
%   phi_init:                  initial level set function 
%   ghostcell_width:           number of ghostcells for phi at boundary 
%                                of computational domain
%   dX:                        array containing the grid spacing
%                                in coordinate directions
%   max_iterations:            maximum number of reinitialization steps 
%                                to take
%                                (default = 100)
%   spatial_derivative_order:  order of discretization for spatial derivative 
%                                (default = 5)
%   tvdrk_order:               order of discretization for time integration
%                                (default = 3)
%
% Return value:
%   phi:                       reinitialized level set function
%
% NOTES:
% - All data arrays are assumed to be in the order generated by the
%   MATLAB meshgrid() function.  That is, for 2D arrays, data corresponding
%   to the point (x_i,y_j) is stored at index (j,i); for 3D arrays, data
%   corresponding to the point (x_i,y_j,z_k) is stored at index (j,i,k).
%
% - When dX is a scalar, it is assumed that the grid spacing in each
%   coordinate direction is the same.  Otherwise, dX is treated as
%   a vector with dX(1) = the grid spacing in the x-direction, 
%   dX(2) = the grid spacing in the y-direction, etc.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Copyright:  (c) 2005-2008 Kevin T. Chu and Masa Prodanovic
% Revision:   $Revision$
% Modified:   $Date$
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function phi = reinitializeLevelSetFunction(phi_init, ...
                                            ghostcell_width, ...
                                            dX, ...
                                            max_iterations, ...
                                            spatial_derivative_order, ...
                                            tvdrk_order)

% parameter checks
if (nargin < 3)
  error('MATLAB:missingArgs','reinitializeLevelSetFunction:missing arguments');
end

if (nargin < 4)
  max_iterations = 100;
else 
  if (max_iterations < 0)
    max_iterations = 100;
  end
end
if (nargin < 5)
  spatial_derivative_order = 5;
else 
  if ( (spatial_derivative_order ~= 1) & (spatial_derivative_order ~= 2) ...
     & (spatial_derivative_order ~= 3) & (spatial_derivative_order ~= 5) )

    error('reinitializeLevelSetFunction:Invalid spatial derivative order...only 1, 2, 3, and 5 are supported');
  end
end
if (nargin < 6)
  tvdrk_order = 3;
else 
  if ( (tvdrk_order ~= 1) & (tvdrk_order ~= 2) & (tvdrk_order ~= 3) )
    error('reinitializeLevelSetFunction:Invalid time integration order...only 1, 2, and 3 are supported');
  end
end

% determine dimensionality of problem
num_dims = ndims(phi_init);
if (num_dims < 2 | num_dims > 3)
  error('reinitializeLevelSetFunction:Invalid dimension...only 2D and 3D problems supported');
end

% compute dX 
if (isscalar(dX))
  dX = dX*ones(num_dims,1);
end

% compute dt
dt = 0.5*min(dX);

% initialize loop variables
count = 0;
phi = phi_init;

% begin reinitialization loop {
while (count < max_iterations) 

  % update phi_cur
  phi_cur = phi;

  if (num_dims == 2) 

    [phi_x_plus, phi_y_plus, phi_x_minus, phi_y_minus] = ...
      computePlusAndMinusDerivatives2D(phi_cur, ghostcell_width, dX, ...
                                       spatial_derivative_order);

    reinit_rhs = COMPUTE_REINIT_EQN_RHS_2D(phi_cur, ...
                                           ghostcell_width, ...
                                           phi_x_plus, phi_y_plus,  ...
                                           phi_x_minus, phi_y_minus,  ...
                                           dX);
    % take TVDRK time step
    phi = phi_cur + dt*reinit_rhs;

    if (tvdrk_order == 2)  % begin TVDRK cases {

      [phi_x_plus, phi_y_plus, phi_x_minus, phi_y_minus] = ...
        computePlusAndMinusDerivatives2D(phi, ghostcell_width, dX, ...
                                         spatial_derivative_order);

      reinit_rhs = COMPUTE_REINIT_EQN_RHS_2D(phi, ...
                                             ghostcell_width, ...
                                             phi_x_plus, phi_y_plus,  ...
                                             phi_x_minus, phi_y_minus,  ...
                                             dX);

      % complete TVDRK2 time step
      phi = 0.5*(phi_cur + phi + dt*reinit_rhs);

    elseif (tvdrk_order == 3) 

      [phi_x_plus, phi_y_plus, phi_x_minus, phi_y_minus] = ...
        computePlusAndMinusDerivatives2D(phi, ghostcell_width, dX, ...
                                         spatial_derivative_order);

      reinit_rhs = COMPUTE_REINIT_EQN_RHS_2D(phi, ...
                                             ghostcell_width, ...
                                             phi_x_plus, phi_y_plus,  ...
                                             phi_x_minus, phi_y_minus,  ...
                                             dX);

      % take TVDRK3 Stage 2 time step
      phi = 0.75*phi_cur + 0.25*(phi + dt*reinit_rhs);

      [phi_x_plus, phi_y_plus, phi_x_minus, phi_y_minus] = ...
        computePlusAndMinusDerivatives2D(phi, ghostcell_width, dX, ...
                                         spatial_derivative_order);

      reinit_rhs = COMPUTE_REINIT_EQN_RHS_2D(phi, ...
                                             ghostcell_width, ...
                                             phi_x_plus, phi_y_plus,  ...
                                             phi_x_minus, phi_y_minus,  ...
                                             dX);

      % complete TVDRK3 time step
      phi = phi_cur/3 + 2/3*(phi + dt*reinit_rhs);

    end % } end TVDRK cases
  
  elseif (num_dims == 3) 

    [phi_x_plus, phi_y_plus, phi_z_plus, ...
     phi_x_minus, phi_y_minus, phi_z_minus] = ...
      computePlusAndMinusDerivatives3D(phi_cur, ghostcell_width, dX, ...
                                       spatial_derivative_order);

    reinit_rhs = COMPUTE_REINIT_EQN_RHS_3D(phi_cur, ...
                                           ghostcell_width, ...
                                           phi_x_plus, ...
                                           phi_y_plus, ...
                                           phi_z_plus, ...
                                           phi_x_minus, ...
                                           phi_y_minus,  ...
                                           phi_z_minus,  ...
                                           dX);
    % take TVDRK time step
    phi = phi_cur + dt*reinit_rhs;

    if (tvdrk_order == 2)  % begin TVDRK cases {

      [phi_x_plus, phi_y_plus, phi_z_plus, ...
       phi_x_minus, phi_y_minus, phi_z_minus] = ...
        computePlusAndMinusDerivatives3D(phi, ghostcell_width, dX, ...
                                         spatial_derivative_order);

      reinit_rhs = COMPUTE_REINIT_EQN_RHS_3D(phi, ...
                                             ghostcell_width, ...
                                             phi_x_plus, ...
                                             phi_y_plus, ...
                                             phi_z_plus, ...
                                             phi_x_minus, ...
                                             phi_y_minus,  ...
                                             phi_z_minus,  ...
                                             dX);

      % complete TVDRK2 time step
      phi = 0.5*(phi_cur + phi + dt*reinit_rhs);

    elseif (tvdrk_order == 3) 

      [phi_x_plus, phi_y_plus, phi_z_plus, ...
       phi_x_minus, phi_y_minus, phi_z_minus] = ...
        computePlusAndMinusDerivatives3D(phi, ghostcell_width, dX, ...
                                         spatial_derivative_order);

      reinit_rhs = COMPUTE_REINIT_EQN_RHS_3D(phi, ...
                                             ghostcell_width, ...
                                             phi_x_plus, ...
                                             phi_y_plus, ...
                                             phi_z_plus, ...
                                             phi_x_minus, ...
                                             phi_y_minus,  ...
                                             phi_z_minus,  ...
                                             dX);

      % take TVDRK3 Stage 2 time step
      phi = 0.75*phi_cur + 0.25*(phi + dt*reinit_rhs);

      [phi_x_plus, phi_y_plus, phi_z_plus, ...
       phi_x_minus, phi_y_minus, phi_z_minus] = ...
        computePlusAndMinusDerivatives3D(phi, ghostcell_width, dX, ...
                                         spatial_derivative_order);

      reinit_rhs = COMPUTE_REINIT_EQN_RHS_3D(phi, ...
                                             ghostcell_width, ...
                                             phi_x_plus, ...
                                             phi_y_plus, ...
                                             phi_z_plus, ...
                                             phi_x_minus, ...
                                             phi_y_minus,  ...
                                             phi_z_minus,  ...
                                             dX);

      % complete TVDRK3 time step
      phi = phi_cur/3 + 2/3*(phi + dt*reinit_rhs);

    end % } end TVDRK cases
  
  end

  % update count
  count = count + 1;

end % } end reinitialization loop 
