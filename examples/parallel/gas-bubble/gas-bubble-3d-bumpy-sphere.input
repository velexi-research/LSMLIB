/*
 * File:        gas-bubble-3d-bumpy-sphere.input
 * Description: input file for 3d gas bubble problem
 */


Main {
  // Base name for output files.
  base_name = "GAS_BUBBLE_3D"
  // Whether to log all nodes in a parallel run.
  log_all_nodes = TRUE

  // Problem dimension
  dim = 3

  // Restart parameters
  restart_interval = 100

  // Visualization parameters
  viz_write_interval = 25
  use_visit = TRUE
  visit_number_procs_per_file = 1

  // Set to 0 to have no limit on maximum number of time steps
  max_num_time_steps = 0
}

CartesianGeometry {
  //  Specify lower/upper corners of the computational domain and a
  //  set of non-overlapping boxes defining domain interior.  If union 
  //  of boxes is not a parallelpiped, lower/upper corner data corresponds 
  //  to min/max corner indices over all boxes given.
  //  x_lo  -- (double array) lower corner of computational domain [REQD]
  //  x_up  -- (double array) upper corner of computational domain [REQD]
  //  domain_boxes  -- (box array) set of boxes that define interior of 
  //                   hysical domain. [REQD]
  //  periodic_dimension -- (int array) coordinate directions in which 
  //                        domain is periodic.  Zero indicates not
  //                        periodic, non-zero value indicates periodicity.
  //                        [0]
  domain_boxes = [(0,0,0), (49,49,49)]
  x_lo         = -1, -1, -1
  x_up         = 1, 1, 1

  periodic_dimension = 1, 1, 1
}


LevelSetMethodAlgorithm{ 

  LevelSetFunctionIntegrator {
    start_time  = 0.0
    end_time    = 1.0
  
    spatial_derivative_type  = "WENO"
    spatial_derivative_order = 5
    tvd_runge_kutta_order    = 3
  
    reinitialization_interval  = 5
    reinitialization_max_iters = 0
    reinitialization_stop_dist = 0.5
 
    lower_bc_phi_0 = 1,1,1
    upper_bc_phi_0 = 1,1,1
 
    use_AMR = FALSE
    refinement_cutoff_value = 0.25
    tag_buffer= 2,2,2,2,2,2

    verbose_mode = FALSE // default: FALSE

  } // end of LevelSetFunctionIntegrator database
  
  
  LevelSetMethodGriddingAlgorithm {
    max_levels = 1 

    ratio_to_coarser {
      level_1            = 2, 2, 2
    }

    largest_patch_size {
      level_0 = 50,50
      // all finer levels will use same values as level_0...
    }

    tagging_method = "GRADIENT_DETECTOR"

    // NOTE: All fine levels MUST be at least two grid cells away 
    // from the physical boundary due to the ghost cell requirements 
    // of the velocity calculation
    //  tagging_method = "REFINE_BOXES"
    RefineBoxes {
    //    level_0 = [(10,10), (16,16)] , [(0,0),(9,15)]
    //etc.
    }

    LoadBalancer {
      // the default load balancer input parameters are usually sufficient
    }

  } // end LevelSetMethodGriddingAlgorithm database

} // end of LevelSetMethodAlgorithm database


VelocityFieldModule {
  // Physical parameters
  // Note: equilibrium shape is a sphere of radius 0.5
  K = 1.3333333333333333
  P_ext = 0
  sigma = 2.0

  // Numerical parameters
  use_field_extension = TRUE

  // Field extension algorithm parameters
  FieldExtensionAlgorithm{
    spatial_derivative_type  = "ENO"
    spatial_derivative_order = 1
    tvd_runge_kutta_order    = 1

    max_iterations = 0
    stop_distance = 0.5

    verbose_mode = FALSE // default: FALSE
  }
}

PatchModule {
  initial_level_set = 1
  center = 0.0, 0.0, 0.0
  radius = 0.5
}
